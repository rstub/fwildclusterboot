# get_model_frame(cbind(1, lm_robust_fit))
# )
data <- get_model_frame(object)
# if fixed effects are specified, demean:
fml <- Formula::Formula(eval(object$call$formula, envir =  attr(object$terms, ".Environment")))
object
object <- felm_fit
library(lfe)
library(fixest)
lm_fit <- lm(proposition_vote ~ treatment + ideology + log_income + Q1_immigration , weights = NULL, data = voters)
library(fwildclusterboot)
B <- 1000
seed <- 421
set.seed(seed)
voters <- create_data_1(N = 3000, N_G = 20, icc = 0.01)
head(voters)
library(lfe)
library(fixest)
lm_fit <- lm(proposition_vote ~ treatment + ideology + log_income + Q1_immigration , weights = NULL, data = voters)
feols_fit <- feols(proposition_vote ~ treatment + ideology + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
feols_fit1 <- feols(proposition_vote ~ treatment + ideology + log_income + Q1_immigration, weights = NULL, data = voters)
felm_fit <- felm(proposition_vote ~ treatment + ideology + log_income | Q1_immigration, weights = NULL, data = voters)
felm_fit1 <- felm(proposition_vote ~ treatment + ideology + log_income + Q1_immigration, weights = NULL, data = voters)
# get_model_frame <- function(mod) {
#   model.frame(formula = mod$call$formula,
#               data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
#               drop.unused.levels = TRUE)
# }
get_model_frame <- function(mod) {
if(class(mod) %in% c("lm", "lm_robust")){
res <- model.frame(formula = eval(mod$call$formula, envir =  attr(mod$terms, ".Environment")),
data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
drop.unused.levels = TRUE)
} else if(class(mod) == "felm"){
formula <- formula(Formula::Formula(eval(mod$call$formula, envir =  attr(mod$terms, ".Environment"))), lhs = 1, rhs = 1)
res <- model.frame(formula = formula,
data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
drop.unused.levels = TRUE)
} else if(class(mod) == "fixest"){
res <- model.frame(formula = eval(mod$call$fml, envir =  attr(mod$terms, ".Environment")),
data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
drop.unused.levels = TRUE)
} else{
stop("The boottest method is only defined for objects of class lm, lm_robust, felm and feols.")
}
res
}
get_model_fe <- function(mod) {
if(class(mod) == "lm_robust"){
res <- model.frame(formula = eval(mod$call$fixed_effects, envir =  attr(mod$terms, ".Environment")),
data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
drop.unused.levels = TRUE)
} else if(class(mod) == "felm"){
formula <- formula(Formula::Formula(eval(mod$call$formula, envir =  attr(mod$terms, ".Environment"))), lhs = 0, rhs = 2)
res <- model.frame(formula = formula,
data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
drop.unused.levels = TRUE)
} else if(class(mod) == "fixest"){
formula <- as.formula(paste(" ~ ", paste(eval(mod$call$fixef), collapse= "+")))
res <- model.frame(formula = formula,
data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
drop.unused.levels = TRUE)
} else{
stop("The boottest method is only defined for objects of class lm, lm_robust, felm and feols.")
}
res
}
get_model_clusters <- function(mod) {
if(class(mod) == "lm_robust"){
res <- model.frame(formula = eval(mod$call$clusters, envir =  attr(mod$terms, ".Environment")),
data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
drop.unused.levels = TRUE)
} else if(class(mod) == "felm"){
formula <- formula(Formula::Formula(eval(mod$call$formula, envir =  attr(mod$terms, ".Environment"))), lhs = 0, rhs = 2)
res <- model.frame(formula = formula,
data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
drop.unused.levels = TRUE)
} else if(class(mod) == "fixest"){
formula <- as.formula(paste(" ~ ", paste(eval(mod$call$fixef), collapse= "+")))
res <- model.frame(formula = formula,
data = eval(mod$call$data, envir =  attr(mod$terms, ".Environment")),
drop.unused.levels = TRUE)
} else{
stop("The boottest method is only defined for objects of class lm, lm_robust, felm and feols.")
}
res
}
# get_model_fe(lm_robust_fit)
#
# res <- demean(cbind(get_model_frame(lm_robust_fit)), get_model_fe(lm_robust_fit))
#
# head(res)
# unique(res$intercept)
# head(
# get_model_frame(cbind(1, lm_robust_fit))
# )
#boottest.lm(lm_fit, 1:2000, B = 1000, seed = 1, param = "x2", beta0 = NULL)
object <- felm_fit
clustid = voters$group_id
B <- 10000
seed <- 1
param <- "treatment"
beta0 <- 0
conf_int <- TRUE
data <- get_model_frame(object)
# if fixed effects are specified, demean:
fml <- Formula::Formula(eval(object$call$formula, envir =  attr(object$terms, ".Environment")))
if(suppressWarnings(formula(fml, lhs = 0, rhs = 2) == "~0")){
data <- as.data.frame(data)
#R0 <- as.numeric(param == c(rownames(object$coefficients)))
} else{
fixed_effects <- get_model_fe(object)
demean_data <- fixest::demean(data, fixed_effects)
data <- as.data.frame(demean_data)
#R0 <- as.numeric(param == c(rownames(object$coefficients)))
}
if(!is.null(object$call$weights)){
stop("Function currently does not allow weights.")
}
if(!is.null(seed)){
set.seed(seed)
} else if(is.null(seed)){
set.seed(2)
}
# retrieve clusters / multiple clusters
if(inherits(clustid, "formula")) {
clustid_tmp <- expand.model.frame(object, clustid, na.expand = FALSE)
clustid <- model.frame(clustid, clustid_tmp, na.action = na.pass)
} else {
clustid <- as.data.frame(clustid, stringsAsFactors = FALSE)
}
if(!(param %in% c(rownames(object$coefficients)))){
warning("Parameter to test not in model or all. Please specify appropriate parameters to test.")
}
# how many clustids? uniway/multiway?
clustid_dims <- ncol(clustid)
# Handle omitted or excluded observations
if(!is.null(object$na.action)) {
if(class(object$na.action) == "exclude") {
clustid <- clustid[-object$na.action,]
} else if(class(object$na.action) == "omit") {
clustid <- clustid[-object$na.action,]
}
clustid <- as.data.frame(clustid)  # silly error somewhere
}
if(is.null(beta0)){
beta0 <- 0
}
# Factors in our clustiding variables can potentially cause problems
# Blunt fix is to force conversion to characters
i <- !sapply(clustid, is.numeric)
clustid[i] <- lapply(clustid[i], as.character)
groupvars <- names(coef(object))
depvar <- names(object$response)
formula <- formula(Formula::Formula(eval(object$call$formula, envir =  attr(object$terms, ".Environment"))), lhs = 1, rhs = 1)
model_frame <- model.frame(formula, data = data)
Y <- model.response(model_frame)
X <- model.matrix(formula, data = data)
R0 <- as.numeric(param == colnames(X))
N <- length(Y)
k <- ncol(X)
Xr <- X[, -which(R0 == 1)] # delete rows that will be tested
# Yr for constraint leas squares with beta0 = c
Yr <- Y - X[, which(R0 == 1)] * beta0
#clustid <- as.vector(clustid)
#clustid <- rep(1:20, 100)
N_G <- nrow(unique(clustid)) #number of clusters
if(N_G > 2000){
warning(paste("You are estimating a model with more than 200 clusters. Are you sure you want to proceed with bootstrap standard errors instead of asymptotic sandwich standard errors? The more clusters in the data, the longer the estimation process."))
}
# error under the null hypothesis
#u_hat <- Y - Xr %*% solve(t(Xr) %*% Xr) %*% t(Xr) %*% Y # N x 1 matrix
u_hat <- Yr - Xr %*% solve(t(Xr) %*% Xr) %*% t(Xr) %*% Yr # N x 1 matrix
invXX <- solve(t(X) %*% X) # k x k matrix
v <- matrix(sample(c(1, -1), N_G * (B + 1), replace = TRUE), N_G, B + 1) # rademacher weights for all replications
v[,1] <- 1
XinvXXr <- X %*% (invXX %*% R0) # N x 1
SXinvXXRu_prep <- data.table::data.table(prod = XinvXXr * matrix(rep(u_hat, 1), N, 1) , clustid = clustid)
SXinvXXRu <- as.matrix(SXinvXXRu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
if(ncol(SXinvXXRu) == 1){
SXinvXXRu <- as.vector(SXinvXXRu)
}
SXinvXXRX_prep <- data.table::data.table(prod = matrix(rep(XinvXXr, k), N, k) * X, clustid = clustid)
SXinvXXRX <- as.matrix(SXinvXXRX_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
SXu_prep <- data.table::data.table(prod = X * matrix(rep(u_hat, k), N, k), clustid = clustid)
SXu <- as.matrix(SXu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
numer <- SXinvXXRu %*% v
J <- (diag(SXinvXXRu) - SXinvXXRX  %*% invXX %*% t(SXu)) %*% v
#hypothesis <- c(0, rep(beta0, B))
#hypothesis <- c(beta0, rep(0, B))
t <- abs(numer)  / sqrt(colSums(J * J))    # note: absolute value is taken here - no negative t-stats
t_boot <- t[2:(B + 1)]
#t_conf <- quantile(t_boot, c(0.025, 0.975))
#conf_int <- 2*t[1] - t_conf
#t_boot <- t_boot
#p_val <- mean(abs(t[1]) < abs(t_boot - c(rep(beta0, B))))
p_val <- mean(abs(t[1] - beta0) < (t_boot))
p_val
res  <- list(p_val = p_val, X = X, Y = Y, B = B, R0 = R0, param = param, clustid = clustid)
if(is.null(conf_int) || conf_int == TRUE){
conf_int <- invert_p_val_fwc(object, data, clustid, X, Y, param, R0, B, N, k, seed, N_g, invXX, v, Xr, XinvXXr, SXinvXXRX)
res_final <- list(p_val = res[["p_val"]],
conf_int = conf_int,
t_stat = t[1],
regression = object,
param = param,
N = N,
B = B,
clustid = clustid,
depvar = depvar,
N_G = N_G)
} else{
res_final <- list(p_val = res[["p_val"]],
t_stat = t[1],
conf_int = conf_int,
regression = object,
param = param,
N = N,
B = B,
clustid = clustid,
depvar = depvar,
N_G = N_G)
}
res
invert_p_val_fwc <- function(object, data, clustid, X, Y, param, R0, B, N, k, seed, N_g, invXX, v, Xr, XinvXXr, SXinvXXRX, sign_level = 0.95){
if(sign_level > 1 | sign_level < 0){stop("Significance level needs to be between 0 and 1.")}
sign_level <- 1 - sign_level
# this needs to be rewritten so that correct fixed effects are used
if(class(object) == "lm"){
lm_robust_fit <- estimatr::lm_robust(eval(object$call$formula), clusters = as.factor(clustid$clustid), data = data, se_type = "stata")
estimate <- lm_robust_fit$coefficients[names(lm_robust_fit$coefficients) == param]
st_error_guess <- lm_robust_fit$std.error[names(lm_robust_fit$coefficients) == param]
} else if(class(object) == "lm_robust"){
lm_robust_fit <-  estimatr::lm_robust(object$call$formula,
clusters = eval(object$call$clusters),
data = data,
se_type = "stata")
estimate <- lm_robust_fit$coefficients[names(lm_robust_fit$coefficients) == param]
st_error_guess <- lm_robust_fit$std.error[names(lm_robust_fit$coefficients) == param]
} else if(class(object) == "felm"){
lm_robust_fit <-  estimatr::lm_robust(formula(Formula::Formula(eval(object$call$formula, envir =  attr(object$terms, ".Environment"))), lhs = 1, rhs = 1),
clusters = clustid[, "clustid"],
data = data, se_type = "stata")
estimate <- lm_robust_fit$coefficients[names(lm_robust_fit$coefficients) == param]
st_error_guess <- lm_robust_fit$std.error[names(lm_robust_fit$coefficients) == param]
} else if(class(object) == "fixest"){
fit <- fixest:::summary.fixest(object, se = "cluster", cluster = clustid)
estimate <- fit$coefficients[names(object$coefficients) == param]
st_error_guess <- fit$se[names(object$se) == param]
} else {
stop("Function only designed for objects of type lm, lm_robust, felm and feols.")
}
# --------------------------------------------------------------------------------------------- #
# start inversion
#tidy_obj <- broom::tidy(lm_robust_fit)
#setDT(tidy_obj)
#estimate <- as.numeric(tidy_obj[term == param, "estimate"])
#st_error_guess <- as.numeric(tidy_obj[term == param, "std.error"])
# estimate <- lm_robust_fit$coefficients[names(lm_robust_fit$coefficients) == param]
# st_error_guess <- lm_robust_fit$std.error[names(lm_robust_fit$coefficients) == param]
p_val_null <- function(beta0, R0, Y, X, Xr,XinvXXr, clustid,
SXinvXXRu_prep,  k,  N, v, B){
Yr <- Y -Xr0 * beta0
u_hat <- Yr - XrinvXrXrtXr %*% Yr # N x 1 matrix
#XrinvXrXrtXr <- Xr %*% solve(t(Xr) %*% Xr) %*% t(Xr)
SXinvXXRu_prep <- data.table::data.table(prod = XinvXXr * matrix(rep(u_hat, 1), N, 1) , clustid = clustid)
SXinvXXRu <- as.matrix(SXinvXXRu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
if(ncol(SXinvXXRu) == 1){
SXinvXXRu <- as.vector(SXinvXXRu)
}
#a <- function(){
SXu_prep <- data.table::data.table(prod = X * matrix(rep(u_hat, k), N, k), clustid = clustid)
SXu <- as.matrix(SXu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
#}
#b <- function(){
#Sxu1 <- as.matrix(aggregate(X * matrix(rep(u_hat, k), N, k), clustid, sum))
#}
#c <-function(){
#  Sxu2 <- aggregate.Matrix(x = X * matrix(rep(u_hat, k), N, k), groupings = clustid, fun = "sum")
#}
#benchmark(a(), b(), c(), replications = 1000)
#d <- function(){
#  mat <- X * matrix(rep(u_hat, k), N, k)
#  lapply(ncol(mat), function(i) lm(mat[,i] ~ 1 + factor(clustid$clustid)))
#}
#benchmark(a(), d(), replications = 100)
numer <- SXinvXXRu %*% v
J <- (diag(SXinvXXRu) - SXinvXXRX_invXX %*% t(SXu)) %*% v
t <- abs(numer)  / sqrt(colSums(J * J))    # note: absolute value is taken here - no negative t-stats
t_boot <- t[2:(B + 1)]
mean(abs(t[1] - beta0) < (t_boot))
}
# can be smaller than zero bc of -0.5
p_val_null_x <- function(beta0){
p_val_null(beta0, R0 = R0, Y = Y, X = X, Xr = Xr, XinvXXr = XinvXXr, clustid = clustid,
SXinvXXRu_prep = SXinvXXRu_prep, k = k, N = N, v = v, B = B) - sign_level
}
# p-value must cross sign_level
check <- FALSE
inflate_se <- c(1, 3, 5, 10)
j <- 1
while(check == FALSE){
if(j > 4){
break("Boottest confidence set calculation fails because no p-value < sign_level could succesfully
be guessed.")
}
starting_vals <- as.numeric(estimate + c(-inflate_se[j], inflate_se[j]) * st_error_guess)
test_vals <- seq(starting_vals[1], starting_vals[2], (starting_vals[2] - starting_vals[1])/ 25)
XrinvXrXrtXr <- Xr %*% solve(t(Xr) %*% Xr) %*% t(Xr)
SXinvXXRX_invXX <- SXinvXXRX  %*% invXX
Xr0 <- X[, which(R0 == 1)]
#benchmark(p_val_null_x(test_vals[1]))
# get test values
p <- rep(NaN, length(test_vals))
for(i in 1:length(test_vals)){
p[i] <- p_val_null_x(test_vals[i])
}
p <- p + sign_level
#if(sum(p < sign_level) < 1){warning("Need to djust starting values: they are not p < sign_level. Therefore, choose more
#                              extreme starting values.")}
crossings <-  (p < sign_level) - (p > sign_level)
check <- mean(crossings == -1) != 1
j <- j + 1
check
}
x_crossings <- rep(NA, length(test_vals))
for(i in 1:25){
x_crossings[i] <- ifelse(crossings[i] + crossings[i + 1] == 0 || crossings[i] + crossings[i - 1] == 0, 1, 0)
}
#p_val[which(x_crossings == 1)]
#test_vals[which(x_crossings == 1)]
test_vals_higher <- (test_vals[which(x_crossings == 1)])[3:4]
test_vals_higher_max <- test_vals_higher[which.min(abs(test_vals_higher))]
test_vals_lower <- (test_vals[which(x_crossings == 1)])[1:2]
test_vals_lower_max <- test_vals_lower[which.min(abs(test_vals_higher))]
secant_method <- function(f, x1, x2, num = 10, eps = 1e-06, eps1 = 1e-06){
i = 0
while ((abs(x1 - x2) > eps) & (i < num)) {
c = x2 - f(x2) * (x2 - x1)/(f(x2) - f(x1))
x1 = x2
x2 = c
i = i + 1
}
if (abs(f(x2)) < eps1) {
success <- "finding root is successful"
}
success <- "finding root is fail"
res <-
list(root = x2,
function_val = f(x2),
success = success)
res
}
res <- lapply(list(test_vals_lower, test_vals_higher), function(x){
#tmp <-  NLRoot::SMfzero(p_val_null_x , x1 = min(x), x2 = max(x), num = 10, eps = 1e-06)
#tmp <- secant_method(p_val_null_x, x1 = min(x), x2 = max(x))
#tmp
#tmp <- pracma::newtonRaphson(p_val_null_x, x0 =  x, dfun = NULL, maxiter = 25, tol = 1e-4)
#tmp$root
#tmp <- pracma::fzero(p_val_null_x , x = test_vals_higher, maxiter = 10, tol = 1e-12)
#tmp$x
tmp <- pracma::bisect(p_val_null_x , a = min(x), b = max(x), maxiter = 10)
tmp$root
})
conf_int <- unlist(res)
#p_val_null_x(conf_int[1])
#p_val_null_x(conf_int[2] + 0.00001)
return(conf_int)
#conf_int
#lm_robust_fit
#summary(lm_fit)
#toc()
}
res  <- list(p_val = p_val, X = X, Y = Y, B = B, R0 = R0, param = param, clustid = clustid)
if(is.null(conf_int) || conf_int == TRUE){
conf_int <- invert_p_val_fwc(object, data, clustid, X, Y, param, R0, B, N, k, seed, N_g, invXX, v, Xr, XinvXXr, SXinvXXRX)
res_final <- list(p_val = res[["p_val"]],
conf_int = conf_int,
t_stat = t[1],
regression = object,
param = param,
N = N,
B = B,
clustid = clustid,
depvar = depvar,
N_G = N_G)
} else{
res_final <- list(p_val = res[["p_val"]],
t_stat = t[1],
conf_int = conf_int,
regression = object,
param = param,
N = N,
B = B,
clustid = clustid,
depvar = depvar,
N_G = N_G)
}
class(res_final) <- "boottest"
res_final
res_final
object <- res_final
stopifnot(inherits(object, "boottest"))
N <- object$N
B <- object$B
depvar <- object$depvar
#clustid <-
estim_function <- class(object$regression)
numb_clusters <- object$N_G
tidy_object <- round(tidy(object), digits)
cat("\t\n",
sprintf("OLS estimation, Dep.Var: %s\n", depvar),
sprintf("Estimation Function: %s\n", estim_function),
sprintf("Observations:%s\n", N),
sprintf("Standard-errors: Clustered  %s\n", ""),
sprintf("Number of Clusters:  %s\n", numb_clusters),
#sprintf("Adj. R-Squared: %s\n", round(adj_r_squared,6)),
sprintf("%s\n", ""))
cat("\t\n",
sprintf("OLS estimation, Dep.Var: %s\n", depvar),
sprintf("Estimation Function: %s\n", estim_function),
sprintf("Observations:%s\n", N),
sprintf("Standard-errors: Clustered  %s\n", ""),
sprintf("Number of Clusters:  %s\n", numb_clusters),
#sprintf("Adj. R-Squared: %s\n", round(adj_r_squared,6)),
sprintf("%s\n", ""))
return(tidy_object)
tidy_object <- round(tidy(object), digits)
digits = 3
tidy_object <- round(tidy(object), digits)
cat("\t\n",
sprintf("OLS estimation, Dep.Var: %s\n", depvar),
sprintf("Estimation Function: %s\n", estim_function),
sprintf("Observations:%s\n", N),
sprintf("Standard-errors: Clustered  %s\n", ""),
sprintf("Number of Clusters:  %s\n", numb_clusters),
#sprintf("Adj. R-Squared: %s\n", round(adj_r_squared,6)),
sprintf("%s\n", ""))
return(tidy_object)
tidy_object
boot_lm = boottest(lm_fit, clustid = voters$group_id, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_felm = boottest(felm_fit, clustid = voters$group_id, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_felm1 = boottest(felm_fit1, clustid = voters$group_id, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_fixest = boottest(feols_fit, clustid = voters$group_id, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_fixest1 = boottest(feols_fit1, clustid = voters$group_id, B = B, seed = seed, param = "treatment", conf_int = TRUE)
fwildclusterboot:::summary(boot_lm)
fwildclusterboot:::summary(boot_felm)
fwildclusterboot:::summary(boot_felm1)
fwildclusterboot:::summary(boot_fixest)
fwildclusterboot:::summary(boot_fixest1)
summary(boot_lm)
summary(boot_felm)
summary(boot_felm1)
summary(boot_fixest)
summary(boot_fixest1)
tidy.boottest <- function(object){
#'@export
if(class(object$regression) == "felm"){
estimate <- object$regression$coefficients[rownames(object$regression$coefficients) == object$param]
} else{
estimate <- object$regression$coefficients[names(object$regression$coefficients) == object$param]
}
t_stat <- object$t_stat
p_val <- object$p_val
conf_int_lower <- min(object$conf_int)
conf_int_upper <- max(object$conf_int)
res <- data.frame(estimate, t_stat, p_val, conf_int_lower, conf_int_upper)
colnames(res) <- c("Estimate", "t value", "Pr(>|t|)", "CI Lower", "CI Upper")
#rownames(res) <- NA
return(res)
}
summary.boottest <- function(object, digits = 3){
#'@export
stopifnot(inherits(object, "boottest"))
N <- object$N
B <- object$B
depvar <- object$depvar
#clustid <-
estim_function <- class(object$regression)
numb_clusters <- object$N_G
#if(class(object$regression) %in% c("lm", "lm_robust", "felm")){
#  adj_r_squared <- summary(object$regression)$adj.r.squared
#} else{
#  adj_r_squared <- NA
#}
tidy_object <- round(tidy(object), digits)
#treatment_name <- rownames(tidy_object)
#tidy_object <- as.data.frame(round(tidy_object, digits = 3))
#rownames(tidy_object) <- treatment_name
cat("\t\n",
sprintf("OLS estimation, Dep.Var: %s\n", depvar),
sprintf("Estimation Function: %s\n", estim_function),
sprintf("Observations:%s\n", N),
sprintf("Standard-errors: Clustered  %s\n", ""),
sprintf("Number of Clusters:  %s\n", numb_clusters),
#sprintf("Adj. R-Squared: %s\n", round(adj_r_squared,6)),
sprintf("%s\n", ""))
return(tidy_object)
}
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
devtools::check("fwildclusterboot")
devtools::document("fwildclusterboot")
devtools::install("fwildclusterboot")
setwd("C:/Users/alexa/Dropbox/fwildclusterboot/R")
file.sources = list.files(pattern="*.R")
sapply(file.sources, source, .GlobalEnv)
devtools::install("fwildclusterboot")
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
