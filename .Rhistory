#   weights = NULL
#   conf_int = NULL
#   debug = FALSE
#   seed = NULL
# p_val_sandwich <- lmtest::coeftest(object, sandwich::vcovCL(x = object, ~ group_id1 + group_id2)) # 0.554481
check_arg(clustid, "os formula | data.frame | named list")
check_arg(param, "scalar character")
check_arg(B, "scalar numeric ")
check_arg(alpha, "scalar numeric")
check_arg(weights, "NULL")
check_arg(conf_int, "logical scalar | NULL")
check_arg(debug, "logical scalar")
check_arg(seed, "scalar integer | NULL")
check_arg(demean, "logcial scalar | NULL")
check_arg(beta0, "numeric scalar | NULL")
preprocess <- preprocess(object = object,
param = param,
clustid = clustid,
beta0 = beta0,
alpha = alpha)
clustid_dims <- preprocess$clustid_dims
# Invert p-value
point_estimate <- object$coefficients[param]
# if(clustid_dims == 1){
#   # boot algoritm
res <- boot_algo(preprocess)
# compute confidence sets
if(is.null(conf_int) || conf_int == TRUE){
# calculate guess for covariance matrix and standard errors
vcov <- sandwich::vcovCL(object, cluster =  preprocess$clustid)
coefs <- lmtest::coeftest(object, vcov)
se_guess <- coefs[param, "Std. Error"]
res_p_val <- invert_p_val(object = res,
point_estimate = point_estimate,
se_guess = se_guess,
clustid = preprocess$clustid,
X = preprocess$X,
Y = preprocess$Y,
N = preprocess$N,
k = preprocess$k,
v = res$v,
param = param,
R0 = preprocess$R0,
B = B,
beta0 = preprocess$beta0,
alpha = preprocess$alpha)
} else {
res_p_val <- list(conf_int = NA,
p_test_vals = NA,
test_vals = NA)
}
if(clustid_dims == 1){
res_final <- list(point_estimate = point_estimate,
p_val = res[["p_val"]],
conf_int = res_p_val$conf_int,
p_test_vals = res_p_val$p_test_vals,
test_vals = res_p_val$test_vals,
t_stat = res$t_stat,
regression = res$object,
param = param,
N = preprocess$N,
B = B,
clustid = clustid,
#depvar = depvar,
N_G = preprocess$N_G)
} else if(clustid_dims > 1){
res_final <- list(point_estimate = point_estimate,
p_val = res[["p_val"]],
conf_int = res_p_val$conf_int,
p_test_vals = res_p_val$p_test_vals,
test_vals = res_p_val$test_vals,
t_stat = res$t_stat,
regression = res$object,
param = param,
N = preprocess$N,
B = B,
clustid = clustid,
#depvar = depvar,
N_G = preprocess$N_G)
}
class(res_final) <- "boottest"
res_final
}
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
boot_fixest1 = boottest(feols_fit1, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, demean = TRUE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.05)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
#boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = #"treatment", conf_int = TRUE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_lm_5 = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.05)
boot_lm_20 = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.20)
summarize_boot(boot_lm_5)
summarize_boot(boot_lm_20)
confint(feols_fit, "treatment", level = 0.95, se = "cluster", cluster = "group_id1")
confint(feols_fit, "treatment", level = 0.80, se = "cluster", cluster = "group_id1")
library(multiwayvcov)
library(lmtest)
res <- cluster.boot(lm_fit, cluster = ~ group_id1, parallel = TRUE, R = 1000, wild_type = "rademacher")
# 1) results from multiwayvcov
coeftest(lm_fit, res)
# 2) results from fwildclusterboot
summarize_boot(boot_lm)
summarize_boot(boot_fixest)
# 3) sandwich standard errors from fixest
summary(feols_fit, se = "cluster", cluster = "group_id1")
boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest <-  boottest(feols_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest <-  boottest(feols_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm <-  boottest(felm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
summarize_boot(boot_lm)
summarize_boot(boot_fixest)
summarize_boot(boot_felm)
vocv <- vcovCL(lm_fit, ~ group_id1 + group_id2)
coeftest(lm_fit, vcov)
confint(feols_fit, "treatment", level = 0.95, se = "twoway", cluster = c("group_id1", "group_id2"))
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
devtools::document("fwildclusterboot")
library(fwildclusterboot)
B <- 10000
seed <- 424
set.seed(seed)
voters <- create_data_2(N = 10000, N_G1 = 40, icc1 = 0.01, N_G2 = 40, icc2 = 0.01)
head(voters)
library(lfe)
library(fixest)
# 1) boottest based on object of class lm
lm_fit <- lm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration , weights = NULL, data = voters)
# 2) boottest based on object of class fixest
feols_fit <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
feols_fit1 <- feols(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
feols_fit2 <- feols(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration, weights = NULL, data = voters)
# 3) bootest based on object of class felm
felm_fit <- felm(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration | 0 |  group_id1, weights = NULL, data = voters)
felm_fit1 <- felm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
boot_fixest1 = boottest(feols_fit1, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, demean = TRUE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.05)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
#boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = #"treatment", conf_int = TRUE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_lm_5 = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.05)
boot_lm_20 = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.20)
summarize_boot(boot_lm_5)
summarize_boot(boot_lm_20)
confint(feols_fit, "treatment", level = 0.95, se = "cluster", cluster = "group_id1")
confint(feols_fit, "treatment", level = 0.80, se = "cluster", cluster = "group_id1")
library(multiwayvcov)
library(lmtest)
res <- cluster.boot(lm_fit, cluster = ~ group_id1, parallel = TRUE, R = 1000, wild_type = "rademacher")
# 1) results from multiwayvcov
coeftest(lm_fit, res)
# 2) results from fwildclusterboot
summarize_boot(boot_lm)
summarize_boot(boot_fixest)
# 3) sandwich standard errors from fixest
summary(feols_fit, se = "cluster", cluster = "group_id1")
library(sandwich)
library(lmtest)
library(multiwayvcov)
options(boot.ncpus = 4)
rm(boot_lm); rm(boot_fixest); rm(boot_felm); rm(res)
boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
Diagonal(n = 10 )
t(Diagonal(n = 10 ))
aggregate(Diagonal(n = 10 ), sample(1:2, 10, TRUE))
t(aggregate(Diagonal(n = 10 ), sample(1:2, 10, TRUE)))
boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
devtools::document("fwildclusterboot")
library(fwildclusterboot)
B <- 10000
seed <- 424
set.seed(seed)
voters <- create_data_2(N = 10000, N_G1 = 40, icc1 = 0.01, N_G2 = 40, icc2 = 0.01)
head(voters)
library(lfe)
library(fixest)
# 1) boottest based on object of class lm
lm_fit <- lm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration , weights = NULL, data = voters)
# 2) boottest based on object of class fixest
feols_fit <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
feols_fit1 <- feols(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
feols_fit2 <- feols(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration, weights = NULL, data = voters)
# 3) bootest based on object of class felm
felm_fit <- felm(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration | 0 |  group_id1, weights = NULL, data = voters)
felm_fit1 <- felm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
boot_fixest1 = boottest(feols_fit1, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, demean = TRUE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.05)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
#boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = #"treatment", conf_int = TRUE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest <-  boottest(feols_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm <-  boottest(felm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
summarize_boot(boot_lm)
summarize_boot(boot_fixest)
summarize_boot(boot_felm)
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
devtools::document("fwildclusterboot")
library(fwildclusterboot)
B <- 10000
seed <- 424
set.seed(seed)
voters <- create_data_2(N = 10000, N_G1 = 40, icc1 = 0.01, N_G2 = 40, icc2 = 0.01)
head(voters)
library(lfe)
library(fixest)
# 1) boottest based on object of class lm
lm_fit <- lm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration , weights = NULL, data = voters)
# 2) boottest based on object of class fixest
feols_fit <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
feols_fit1 <- feols(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
feols_fit2 <- feols(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration, weights = NULL, data = voters)
# 3) bootest based on object of class felm
felm_fit <- felm(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration | 0 |  group_id1, weights = NULL, data = voters)
felm_fit1 <- felm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, demean = TRUE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.05)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
#boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = #"treatment", conf_int = TRUE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest <-  boottest(feols_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm <-  boottest(felm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
summarize_boot(boot_lm)
summarize_boot(boot_fixest)
summarize_boot(boot_felm)
rm(boot_lm); rm(boot_fixest); rm(boot_felm); rm(res)
boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
#execute all functions in fwildclusterboot
setwd("C:/Users/alexa/Dropbox/fwildclusterboot/R")
file.sources = list.files(pattern="*.R")
sapply(file.sources, source, .GlobalEnv)
set.seed(5)
data <- create_data_2(N = 10000, N_G1 = 20, icc1 = 0.01, N_G2 = 20, icc2 = 0.01)
object <- lm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration , weights = NULL, data = data)
clustid <- ~ group_id1 + group_id2
param <- "treatment"
beta0 = 0
alpha = 0.05
B = 10000
weights = NULL
conf_int = NULL
debug = FALSE
seed = NULL
check_arg(clustid, "os formula | data.frame | named list")
check_arg(param, "scalar character")
check_arg(B, "scalar numeric ")
check_arg(alpha, "scalar numeric")
check_arg(weights, "NULL")
check_arg(conf_int, "logical scalar | NULL")
check_arg(debug, "logical scalar")
check_arg(seed, "scalar integer | NULL")
check_arg(demean, "logcial scalar | NULL")
check_arg(beta0, "numeric scalar | NULL")
preprocess <- preprocess(object = object,
param = param,
clustid = clustid,
beta0 = beta0,
alpha = alpha)
clustid_dims <- preprocess$clustid_dims
# Invert p-value
point_estimate <- object$coefficients[param]
preprocessed_object <- preprocess
X <- preprocessed_object$X
Y <- preprocessed_object$Y
R0 <- preprocessed_object$R0
data <- preprocessed_object$data
N <- preprocessed_object$N
k <- preprocessed_object$k
clustid <- preprocessed_object$clustid
fixed_effects <- preprocessed_object$fixed_effects
beta0 <- preprocessed_object$beta0
N_G <- preprocessed_object$N_G
alpha <- preprocessed_object$alpha
param <- preprocessed_object$param
Xr <- X[, -which(R0 == 1)] # delete rows that will be tested
Xr0 <- matrix(X[, which(R0 == 1)], nrow(X), 1)
# Yr for constraint leas squares with beta0 = c
Yr <- Y - X[, which(R0 == 1)] * beta0
# small sample correction for clusters
G <- sapply(clustid, function(x) length(unique(x)))
small_sample_correction <- G / (G - 1)
Q <- Y - Xr %*% (solve(t(Xr) %*% Xr) %*% (t(Xr) %*% Y))
P <- Xr %*% (solve(t(Xr) %*% Xr) %*% (t(Xr) %*% Xr0)) - Xr0
v <- matrix(sample(c(1, -1), N_G * (B + 1), replace = TRUE), N_G, B + 1) # rademacher weights for all replications
v[,1] <- 1
invXX <- solve(t(X) %*% X) # k x k matrix
XinvXXr <- X %*% (invXX %*% R0) # N x 1
p_val_null <- function(beta0, Q, P, R0, X, XinvXXr, clustid,
SXinvXXRu_prep, v, B, small_sample_correction){
# error under the null hypothesis
#u_hat <- Yr - Xr %*% (solve(t(Xr) %*% Xr) %*% (t(Xr) %*% Yr)) # N x 1 matrix
u_hat <- Q + P %*% matrix(beta0, 1, length(beta0))
uX <- matrix(rep(u_hat, 1), N, k) * X
SuX <- collapse::fsum(uX, clustid$clustid)
tSuX <- t(SuX)
XinvXXRu <- as.vector(XinvXXr * matrix(rep(u_hat, 1), N, 1))
SXinvXXRu <-collapse::fsum(XinvXXr * matrix(rep(u_hat, 1), N, 1), clustid)
#SXinvXXRu <- collapse::fsum(XinvXXRu, clustid$clustid)
XinvXXRuS <- t(collapse::fsum(XinvXXRu, clustid$clustid))
#diag_XinvXXRuS <- t(collapse::fsum(diag(as.vector(XinvXXRu)), clustid$clustid))
diag_XinvXXRuS <- Matrix::t(Matrix.utils::aggregate.Matrix(Matrix::Diagonal(N, as.vector(XinvXXRu)), clustid$clustid))
#tKK <- list()
#JJ <- list()
#n_clustid <- length(unique(clustid$clustid))
#tKK <- array(NA, dim = c(n_clustid, n_clustid, ncol(clustid)))
#i <- 1
tKK <- list()
XinvXXrX <- matrix(rep(XinvXXr, k), N, k) * X
for(x in names(clustid)){
#S_diag_XinvXXRu_S <- collapse::fsum(diag_XinvXXRuS, clustid[x])
S_diag_XinvXXRu_S <- aggregate.Matrix(diag_XinvXXRuS, clustid[x])
SXinvXXrX <-  collapse::fsum(XinvXXrX, clustid[x])
K <- S_diag_XinvXXRu_S - SXinvXXrX %*% invXX %*% tSuX
tKK[[x]] <- small_sample_correction[x] * Matrix::t(K) %*% K # here: add small sample df correction
#i <- i + 1
#tKK[[x]] <-  t(K) %*% K # here: add small sample df correction
#J <- K %*% v
#JJ[[x]] <- small_sample_correction[x] * J * J
}
#JJ_sum <- Reduce("+", JJ)
tKK_sum <- Reduce("+", tKK)
#tKK_sum <- rowSums(tKK, dims = 2)
denom <- colSums(v * tKK_sum %*% v)
numer <- t(SXinvXXRu) %*% v
t <- abs(numer) / denom
t_boot <- t[2:(B + 1)]
p_val <- mean(abs(t[1] - beta0) < (t_boot))
res <- list(p_val = p_val,
t = t,
t_boot = t_boot)
}
p_val_res <- p_val_null(beta0 = beta0, Q =Q, P = P, R0 = R0, X = X, XinvXXr = XinvXXr, clustid = clustid,
SXinvXXRu_prep = SXinvXXRu_prep, v = v, B = B, small_sample_correction = small_sample_correction)
p_val <- p_val_res$p_val
t <- p_val_res$t
t_boot <- p_val_res$t_boot
# calculate guess for covariance matrix and standard errors
vcov <- sandwich::vcovCL(object, cluster =  preprocess$clustid)
coefs <- lmtest::coeftest(object, vcov)
se_guess <- coefs[param, "Std. Error"]
res_p_val <- invert_p_val(object = res,
point_estimate = point_estimate,
se_guess = se_guess,
clustid = preprocess$clustid,
X = preprocess$X,
Y = preprocess$Y,
N = preprocess$N,
k = preprocess$k,
v = res$v,
param = param,
R0 = preprocess$R0,
B = B,
beta0 = preprocess$beta0,
alpha = preprocess$alpha)
# if(clustid_dims == 1){
#   # boot algoritm
res <- boot_algo(preprocess)
res$p_val
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
devtools::document("fwildclusterboot")
library(fwildclusterboot)
B <- 10000
seed <- 424
set.seed(seed)
voters <- create_data_2(N = 10000, N_G1 = 40, icc1 = 0.01, N_G2 = 40, icc2 = 0.01)
head(voters)
library(lfe)
library(fixest)
# 1) boottest based on object of class lm
lm_fit <- lm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration , weights = NULL, data = voters)
# 2) boottest based on object of class fixest
feols_fit <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
feols_fit1 <- feols(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
feols_fit2 <- feols(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration, weights = NULL, data = voters)
# 3) bootest based on object of class felm
felm_fit <- felm(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration | 0 |  group_id1, weights = NULL, data = voters)
felm_fit1 <- felm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
boot_fixest1 = boottest(feols_fit1, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, demean = TRUE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.05)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
#boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = #"treatment", conf_int = TRUE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
library(sandwich)
library(lmtest)
library(multiwayvcov)
options(boot.ncpus = 4)
rm(boot_lm); rm(boot_fixest); rm(boot_felm); rm(res)
boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
devtools::document("fwildclusterboot")
devtools::test("C:/Users/alexa/Dropbox/fwildclusterboot")
library(fwildclusterboot)
B <- 10000
seed <- 424
set.seed(seed)
voters <- create_data_2(N = 10000, N_G1 = 40, icc1 = 0.01, N_G2 = 40, icc2 = 0.01)
head(voters)
library(lfe)
library(fixest)
# 1) boottest based on object of class lm
lm_fit <- lm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration , weights = NULL, data = voters)
# 2) boottest based on object of class fixest
feols_fit <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
feols_fit1 <- feols(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
feols_fit2 <- feols(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration, weights = NULL, data = voters)
# 3) bootest based on object of class felm
felm_fit <- felm(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration | 0 |  group_id1, weights = NULL, data = voters)
felm_fit1 <- felm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
boot_fixest1 = boottest(feols_fit1, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)
# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
library(sandwich)
library(lmtest)
library(multiwayvcov)
options(boot.ncpus = 4)
rm(boot_lm); rm(boot_fixest); rm(boot_felm); rm(res)
boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest <-  boottest(feols_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm <-  boottest(felm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
summarize_boot(boot_lm)
summarize_boot(boot_fixest)
summarize_boot(boot_felm)
res <- cluster.boot(lm_fit, cluster = ~group_id1 + group_id2, R = 1000, wild_type = "rademacher", parallel = TRUE)
summarize_boot(boot_lm)
summarize_boot(boot_fixest)
summarize_boot(boot_felm)
vocv <- vcovCL(lm_fit, ~ group_id1 + group_id2)
coeftest(lm_fit, vcov)
