B = B,
beta0 = preprocess$beta0,
alpha = preprocess$alpha,
W = preprocess$W,
n_fe = preprocess$n_fe,
N_G = preprocess$N_G)
} else {
res_p_val <- list( conf_int = NA,
p_test_vals = NA,
test_vals = NA)
}
# if(clustid_dims == 1){
#   # boot algoritm
res <- boot_algo(preprocess)
res
# Part 1) Check Arguments
check_arg(clustid, "character scalar | character vector")
check_arg(beta0, "numeric scalar | NULL")
check_arg(alpha, "numeric scalar | NULL")
check_arg(fe, "character scalar | NULL")
if(is.null(alpha)){
alpha <- 0.05
}
if(!is.numeric(alpha) || alpha > 1 || alpha < 0 || length(alpha) > 1){
stop("The level of significance alpha must be a numeric between 0 and 1")
}
if(!is.null(object$call$weights)){
stop("Function currently does not allow weights.")
}
if(!(param %in% c(names(object$coefficients)))){
stop("Parameter to test not in model or all. Please specify appropriate parameters to test.")
}
if(is.null(beta0)){
beta0 <- 0
}
model_coef_names <- names(object$coefficients)
#model_clustid_names <- names()
model_fe_names <- object$fixef_vars
numb_fe <- length(model_fe_names)
model_param_names <- c(model_coef_names, model_fe_names)
fml <- object$fml
fml_fe <- formula(paste0(fml, paste0("+",c(model_fe_names), collapse = "+")))
fml_all <- formula(paste0(fml, paste0("+",c(model_fe_names, clustid), collapse = "+")))
depvar <- as.character(formula.tools::lhs(object$fml))
data <- model.frame(formula = fml_fe,
data = eval(object$call$data, envir =  attr(object$terms, ".Environment")),
drop.unused.levels = TRUE)
data_all <- model.frame(formula = fml_all,
data = eval(object$call$data, envir =  attr(object$terms, ".Environment")),
drop.unused.levels = TRUE)
data_diff <- nrow(data) - nrow(data_all)
if(data_diff == 1){
warning(paste(data_diff, "observation deleted due to NA values in the cluster variables. In consequence, the bootstrap is estimated on a different sample than the regression model. If you want to guarantee that both bootstrap and model are estimated on the same sample, please delete missing values from the cluster variables prior to using boottest()."))
} else if(data_diff > 1){
warning(paste(data_diff, "observations deleted due to NA values in the cluster variables. In consequence, the bootstrap is estimated on a different sample than the regression model. If you want to guarantee that both bootstrap and model are estimated on the same sample, please delete missing values from the cluster variables prior to using boottest()."))
}
# now create clusters
clustid <- as.data.frame(data_all[, clustid])
clustid_dims <- ncol(clustid)
if(is.null(clustid_dims)){clustid_dims <- 1}
i <- !sapply(clustid, is.numeric)
clustid[i] <- lapply(clustid[i], as.character)
if(clustid_dims == 2){
names(clustid) <- c("clustid_1", "clustid_2")
clustid$clustid <- paste0(clustid$clustid_1, "-", clustid$clustid_2)
}
N_G <- sapply(clustid, function(x) length(unique(x)))
if(clustid_dims == 1){
if(max(N_G) > 200){
warning(paste("You are estimating a model with more than 200 clusters. Are you sure you want to proceed with bootstrap standard errors instead of asymptotic sandwich standard errors? The more clusters in the data, the longer the estimation process."))
}
} else if(clustid_dims > 1){
if(max(N_G) > 200){
warning(paste("You are estimating a model with more than 200 clusters. The more clusters in the data, the longer the estimation process."))
}
}
# now create fixed effects
if(!is.null(fe)){
if(numb_fe == 1){
fml_design <- fml
} else if(numb_fe > 1){
fml_design <- formula(paste0(as.character(fml), "+", paste0(model_fe_names[model_fe_names != fe], collapse = "+")))
}
model_frame <- model.frame(fml_design, data_all)
X <- model.matrix(model_frame, data = data_all)
Y <- model.response(model_frame)
N <- nrow(X)
k <- ncol(X)
fixed_effect <- data_all[, fe]
# demean X and Y
X <- collapse::fwithin(X, fixed_effect)#
Y <- collapse::fwithin(Y, fixed_effect)
fixed_effect_W <- fixed_effect
levels(fixed_effect_W) <- 1 / table(fixed_effect)
W <- Matrix::Diagonal(N, as.numeric(as.character(fixed_effect_W)))
n_fe <- length(unique(fixed_effect))
} else{
model_frame <- model.frame(fml_fe, data_all)
X <- model.matrix(model_frame, data = data_all)
Y <- model.response(model_frame)
N <- nrow(X)
k <- ncol(X)
W <- NULL
n_fe <- NULL
fixed_effect <- NULL
}
R0 <- as.numeric(param == colnames(X))
res_preprocess <- list(fixed_effect = fixed_effect,
param = param,
data = data,
clustid = clustid,
clustid_dims = clustid_dims,
N = N,
k = k,
Y = Y,
X = X,
#depvar = depvar,
#groupvars = groupvars,
beta0 = beta0,
clustid_dims,
R0 = R0,
N_G = N_G,
alpha = alpha,
n_fe = n_fe,
W = W)
if(clustid_dims == 1){
class(res_preprocess) <- "oneclust"
} else if(clustid_dims > 1){
class(res_preprocess) <- "multclust"
}
res_preprocess
summary(object, se = "cluster", cluster = preprocess$clustid)
setwd("C:/Users/alexa/Dropbox/fwildclusterboot/R")
file.sources = list.files(pattern="*.R")
sapply(file.sources, source, .GlobalEnv)
# set.seed(6261)
voters <- create_data_2(N = 10000, N_G1 = 20, icc1 = 0.01, N_G2 = 20, icc2 = 0.01, numb_fe1 = 10, numb_fe2 = 10, seed = 1234)
voters[1:2, proposition_vote:=NA]
voters[3, group_id1 := NA]      #
object <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
clustid <- "group_id1"
fe = NULL
param <- "treatment"
B = 10000
weights = NULL
conf_int = NULL
debug = FALSE
seed = NULL
beta0 = NULL
alpha = NULL
# calculate guess for covariance matrix and standard errors
vcov <- sandwich::vcovCL(object, cluster = preprocess$clustid)
preprocess$clustid
clustid
# calculate guess for covariance matrix and standard errors
vcov <- sandwich::vcovCL(object, cluster = clustid)
# calculate guess for covariance matrix and standard errors
vcov <- sandwich::vcovCL(object, cluster = clustid)
object
object
object
object <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
clustid <- "group_id1"
fe = NULL
param <- "treatment"
B = 10000
weights = NULL
conf_int = NULL
debug = FALSE
seed = NULL
beta0 = NULL
alpha = NULL
# calculate guess for covariance matrix and standard errors
vcov <- sandwich::vcovCL(object, cluster = clustid)
se_guess <- object$se
se_guess
se_guess["param"]
param
se_guess[param]
se_guess <- object$se[param]
se_guess
se_guess <- object$se[param]
res_p_val <- invert_p_val(object = res,
point_estimate = point_estimate,
se_guess = se_guess,
clustid = preprocess$clustid,
fixed_effect = preprocess$fixed_effect,
X = preprocess$X,
Y = preprocess$Y,
N = preprocess$N,
k = preprocess$k,
v = res$v,
param = param,
R0 = preprocess$R0,
B = B,
beta0 = preprocess$beta0,
alpha = preprocess$alpha,
W = preprocess$W,
n_fe = preprocess$n_fe,
N_G = preprocess$N_G)
setwd("C:/Users/alexa/Dropbox/fwildclusterboot/R")
file.sources = list.files(pattern="*.R")
sapply(file.sources, source, .GlobalEnv)
# set.seed(6261)
voters <- create_data_2(N = 10000, N_G1 = 20, icc1 = 0.01, N_G2 = 20, icc2 = 0.01, numb_fe1 = 10, numb_fe2 = 10, seed = 1234)
voters[1:2, proposition_vote:=NA]
voters[3, group_id1 := NA]      #
object <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
clustid <- "group_id1"
fe = NULL
param <- "treatment"
B = 10000
weights = NULL
conf_int = NULL
debug = FALSE
seed = NULL
beta0 = NULL
alpha = NULL
check_arg(clustid, "formula")
check_arg(param, "scalar character")
check_arg(B, "scalar numeric ")
check_arg(alpha, "scalar numeric")
check_arg(weights, "NULL")
check_arg(conf_int, "logical scalar | NULL")
check_arg(debug, "logical scalar")
check_arg(seed, "scalar integer | NULL")
check_arg(beta0, "numeric scalar | NULL")
check_arg(fe, "character scalar | NULL")
if(!is.null(seed)){
set.seed(seed)
} else if(is.null(seed)){
set.seed(2)
}
preprocess <- suppressWarnings(preprocess(object = object,
param = param,
clustid = clustid,
beta0 = beta0,
alpha = alpha,
fe = fe))
clustid_dims <- preprocess$clustid_dims
# Invert p-value
point_estimate <- object$coefficients[param]
# if(clustid_dims == 1){
#   # boot algoritm
res <- boot_algo(preprocess)
if(is.null(conf_int) || conf_int == TRUE){
# calculate guess for covariance matrix and standard errors
#vcov <- sandwich::vcovCL(object, cluster = clustid)
#coefs <- lmtest::coeftest(object, vcov)
#se_guess <- coefs[param, "Std. Error"]
se_guess <- object$se[param]
res_p_val <- invert_p_val(object = res,
point_estimate = point_estimate,
se_guess = se_guess,
clustid = preprocess$clustid,
fixed_effect = preprocess$fixed_effect,
X = preprocess$X,
Y = preprocess$Y,
N = preprocess$N,
k = preprocess$k,
v = res$v,
param = param,
R0 = preprocess$R0,
B = B,
beta0 = preprocess$beta0,
alpha = preprocess$alpha,
W = preprocess$W,
n_fe = preprocess$n_fe,
N_G = preprocess$N_G)
} else {
res_p_val <- list( conf_int = NA,
p_test_vals = NA,
test_vals = NA)
}
if(clustid_dims == 1){
res_final <- list(point_estimate = point_estimate,
p_val = res[["p_val"]],
conf_int = res_p_val$conf_int,
p_test_vals = res_p_val$p_test_vals,
test_vals = res_p_val$test_vals,
t_stat = res$t_stat,
regression = res$object,
param = param,
N = preprocess$N,
B = B,
clustid = clustid,
#depvar = depvar,
N_G = preprocess$N_G)
} else if(clustid_dims > 1){
res_final <- list(point_estimate = point_estimate,
p_val = res[["p_val"]],
conf_int = res_p_val$conf_int,
p_test_vals = res_p_val$p_test_vals,
test_vals = res_p_val$test_vals,
t_stat = res$t_stat,
regression = res$object,
param = param,
N = preprocess$N,
B = B,
clustid = clustid,
#depvar = depvar,
N_G = preprocess$N_G)
}
class(res_final) <- "boottest"
res_final
#  library(data.table)
#  library(lfe)
# # library(dreamerr)
setwd("C:/Users/alexa/Dropbox/fwildclusterboot/R")
file.sources = list.files(pattern="*.R")
sapply(file.sources, source, .GlobalEnv)
set.seed(3129)
voters <- create_data_2(N = 10000, N_G1 = 20, icc1 = 0.21, N_G2 = 10, icc2 = 0.01, numb_fe1 = 10, numb_fe2 = 10, seed = 122)
voters[1, group_id1 := NA]
voters[2, proposition_vote := NA]
object <- felm(proposition_vote ~ treatment + Q1_immigration |  ideological_label | 0 | group_id1 + group_id2, data = voters)
fe = "ideological_label"
# fe = NULL
clustid <- ~ group_id1 + group_id2
param <- "treatment"
B = 10000
alpha = NULL
weights = NULL
conf_int = NULL
debug = FALSE
seed = NULL
beta0 = 0
preprocess <- preprocess(object = object,
param = param,
#clustid = clustid,
beta0 = beta0,
alpha = alpha,
fe = fe)
preprocess
# Part 1) Check Arguments
#check_arg(clustid, "character scalar | character vector")
check_arg(beta0, "numeric scalar | NULL")
check_arg(alpha, "numeric scalar | NULL")
check_arg(fe, "character scalar | NULL")
if(is.null(alpha)){
alpha <- 0.05
}
if(!is.numeric(alpha) || alpha > 1 || alpha < 0 || length(alpha) > 1){
stop("The level of significance alpha must be a numeric between 0 and 1")
}
if(!is.null(object$call$weights)){
stop("Function currently does not allow weights.")
}
if(!(param %in% rownames(object$coefficients))){
stop("Parameter to test not in model or all. Please specify appropriate parameters to test.")
}
if(is.null(beta0)){
beta0 <- 0
}
model_coef_names <- rownames(object$coefficients)
fml_wo_fe <- formula(Formula::Formula(object$formula), lhs = 1, rhs = 1)
fml_fe <- formula(Formula::Formula(object$formula), lhs = 0, rhs = 2)
fml_cluster <- formula(Formula::Formula(object$formula), lhs = 0, rhs = 4)
fml_iv <-  formula(Formula::Formula(object$formula), lhs = 0, rhs = 3)
fml_wo_fe
fml_fe
fml_cluster
fml_iv
model_fe_names <- names(object$fe)
numb_fe <- length(model_fe_names)
model_clustid_names <- names(object$clustervar)
fml_all <- formula(paste0(as.character(fml_wo_fe), "+", paste0(c(model_fe_names, model_clustid_names), collapse = "+")))
fml_fe <- formula(paste0(as.character(fml_wo_fe), "+", paste0(c(model_fe_names), collapse = "+")))
depvar <- colnames(object$coefficients)
data_all <- model.frame(formula = fml_all,
data = eval(object$call$data, envir =  attr(object$terms, ".Environment")),
drop.unused.levels = TRUE)
# now create clusters
clustid <- as.data.frame(data_all[, model_clustid_names])
clustid_dims <- ncol(clustid)
if(is.null(clustid_dims)){clustid_dims <- 1}
i <- !sapply(clustid, is.numeric)
clustid[i] <- lapply(clustid[i], as.character)
if(clustid_dims == 2){
names(clustid) <- c("clustid_1", "clustid_2")
clustid$clustid <- paste0(clustid$clustid_1, "-", clustid$clustid_2)
}
N_G <- sapply(clustid, function(x) length(unique(x)))
N_G
if(clustid_dims == 1){
if(max(N_G) > 200){
warning(paste("You are estimating a model with more than 200 clusters. Are you sure you want to proceed with bootstrap standard errors instead of asymptotic sandwich standard errors? The more clusters in the data, the longer the estimation process."))
}
} else if(clustid_dims > 1){
if(max(N_G) > 200){
warning(paste("You are estimating a model with more than 200 clusters. The more clusters in the data, the longer the estimation process."))
}
}
# now create fixed effects
if(!is.null(fe)){
# create covariates X and dependent variable Y
if(numb_fe == 1){
fml_design <- fml_wo_fe
} else if(numb_fe > 1){
fml_design <- formula(paste0(as.character(fml_wo_fe), "+", paste0(model_fe_names[names(model_fe_names) != fe], collapse = "+")))
}
model_frame <- model.frame(fml_design, data_all)
X <- model.matrix(model_frame, data = data_all)
Y <- model.response(model_frame)
N <- nrow(X)
k <- ncol(X)
fixed_effect <- as.data.frame(data_all[, fe])
# demean X and Y
X <- collapse::fwithin(X, fixed_effect)#
Y <- collapse::fwithin(Y, fixed_effect)
fixed_effect_W <- fixed_effect
levels(fixed_effect_W) <- 1 / table(fixed_effect)
W <- Matrix::Diagonal(N, as.numeric(as.character(fixed_effect_W)))
n_fe <- length(unique(fixed_effect))
} else{
model_frame <- model.frame(fml_fe, data_all)
X <- model.matrix(model_frame, data = data_all)
Y <- model.response(model_frame)
W <- NULL
n_fe <- NULL
fixed_effect <- NULL
}
!is.null(fe)
numb_fe == 1
fml_design <- fml_wo_fe
fml_design
model_frame <- model.frame(fml_design, data_all)
X <- model.matrix(model_frame, data = data_all)
Y <- model.response(model_frame)
X
Y
N <- nrow(X)
k <- ncol(X)
N
k
fixed_effect <- as.data.frame(data_all[, fe])
fixed_effect
# demean X and Y
X <- collapse::fwithin(X, fixed_effect)#
Y <- collapse::fwithin(Y, fixed_effect)
X
Y
fixed_effect_W <- fixed_effect
fixed_effect_W
levels(fixed_effect_W) <- 1 / table(fixed_effect)
fixed_effect_W
W <- Matrix::Diagonal(N, as.numeric(as.character(fixed_effect_W)))
fixed_effect_W
levels(fixed_effect_W) <- 1 / table(fixed_effect)
fixed_effect_W
as.character(fixed_effect_W)
fixed_effect_W
as.character(fixed_effect_W)
as.numeric(as.character(fixed_effect_W))
fixed_effect_W
table(fixed_effect_W)
table(as.character(fixed_effect_W))
as.numeric(as.character(fixed_effect_W))
W <- Matrix::Diagonal(N, as.numeric(as.character(fixed_effect_W)))
n_fe <- length(unique(fixed_effect))
n_fe
model_frame <- model.frame(fml_fe, data_all)
R0 <- as.numeric(param == colnames(X))
R0
res_preprocess <- list(fixed_effect = fixed_effect,
param = param,
data = data,
clustid = clustid,
clustid_dims = clustid_dims,
N = N,
k = k,
Y = Y,
X = X,
#depvar = depvar,
#groupvars = groupvars,
beta0 = beta0,
clustid_dims,
R0 = R0,
N_G = N_G,
alpha = alpha,
n_fe = n_fe,
W = W)
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
library(fwildclusterboot)
B <- 10000
seed <- 942413
set.seed(seed)
voters <- create_data_2(N = 10000, N_G1 = 20, icc1 = 0.01, N_G2 = 40, icc2 = 0.01, numb_fe1 = 10, numb_fe2 = 10, seed = seed)
head(voters)
data.table::fwrite(voters, "voters.csv")
library(lfe)
library(fixest)
library(sandwich)
library(multiwayvcov)
# 1) boottest based on object of class lm
lm_fit <- lm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration , weights = NULL, data = voters)
# 2) boottest based on object of class fixest
feols_fit <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
feols_fit1 <- feols(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
feols_fit2 <- feols(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration, weights = NULL, data = voters)
# 3) bootest based on object of class felm
felm_fit <- felm(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration | 0 |  group_id1, weights = NULL, data = voters)
felm_fit1 <- felm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
setwd("C:/Users/alexa/Dropbox")
devtools::install("fwildclusterboot")
