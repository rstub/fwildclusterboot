---
title: "How to set random seeds in fwildclusterboot"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(fwildclusterboot)
```

`fwildclusterboot` allows to run the wild cluster bootstrap through algorithms implemented in three languages: `fwildclusterboot's` initial implementation of the fast algorithm in R, a new memory-sensitive (but slow) implementation via rcpp and last, version 0.8 provides a binding to David Roodman's `WildBootTests.jl` package.

As the bootstrap is a stochastic method, supporting algorithms implemented in multiple languages causes some challenges with random number generation. For each different algorithm, a different seed needs to be set. E.g. if no seed is provided to Julia when running `boottest()` through `WildBootTests.jl`, results will in general not be reproducible. 

To complicate matters, `boottest()` uses different random number generators for its native R algorithm: for performance reasons, for the Rademacher, Webb and Normal distributions, the bootstrap weights $v$ are generated via the `dqrng` package, while for Mammen weights, base R's random number generators are employed. To guarantee reproducibility, different seeds need to be set via different seeding functions: `drqng::dqset.seed()` for Rademacher, Webb and Normal weights and the familiar `set.seed()` for Mammen weights. 

To facilitate reproducibility across random number generators and languages, `fwildclusterboot` implements some workarounds. In short, if no seed is provided as a function argument to `boottest()`, `boottest()` sets an *internal* seed that *inherits* from R's global seed, set via `set.seed()`.

In consequence, it is possible to control all random number generation in `boottest()` via the familiar `set.seed()` function. This means that it is not necessary to set a dedicated seed for Julia when running the wild bootstrap through `WildBootTests.jl`, and it is also not required to set a specific seed for weights created via the `dqrng` package. 

This idea is borrowing from a post by [Rory Nolan ](https://www.r-bloggers.com/2018/09/using-rs-set-seed-to-set-seeds-for-use-in-c-c-including-rcpp/). Rory suggests to use another R function that *stochastically* generates a random integer $x$ *based on the current state of the global R seed* - which is initially set via the familiar `set.seed()` - and to then to use the generated integer as a seed value in either R, Julia or c++. 

Hence when using the Julia or c++ based algorithms, neither `set.seed(1234); boottest(..., seed = NULL);` nor `boottest(..., seed = 1234)` actually pass `1234` as a seed value to Julia or c++. Instead, both create a new integer based on the state of R's global seed, which is implicitly called by the `sample.int(.Machine$integer.max, 1)` function.


## If you don't want to use 'internal seeds'

You can turn off internal seeding by setting a global variable via 

```{r, eval = FALSE}
setBoottest_internal_seed(FALSE)
```
in which case you will have to set appropriate seeds via `set.seed()`, `dqrng::set.seed()` and `Julia.StableRNGs`. This way, you can reproduce bootstrap results from fwildclusterboot versions 0.7 or earlier. 

## Examples: Setting global seeds for all algorithms and distributions via 'set.seed()'

Here is an example in which no seeds are provided to `boottest()`, a global seed is set
via `set.seed()`, and the wild cluster bootstrap is run for different weights and via R, rcpp and Julia. 

```{r}
# load data set voters included in fwildclusterboot
data(voters)
# estimate the regression model via lm
lm_fit <- lm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration , data = voters)

res <- list()
for(x in 1:2){
  set.seed(1234)
  # random number generation via dqrng: 
  boot_lm1 <- boottest(lm_fit, 
                         clustid = "group_id1", 
                         param = "treatment", 
                         B = 9999, 
                         boot_algo = "R", 
                         type = "rademacher")
  # random number generation via base R: 
  boot_lm2 <- boottest(lm_fit, 
                         clustid = "group_id1", 
                         param = "treatment", 
                         B = 9999, 
                         boot_algo = "R", 
                         type = "mammen")
  boot_lm3 <- boottest(lm_fit, 
                         clustid = "group_id1", 
                         param = "treatment", 
                         B = 9999, 
                         boot_algo = "R-lean", 
                         type = "rademacher")
  # random number generation via the StableRNGs Julia package
  boot_lm4 <- boottest(lm_fit, 
                         clustid = "group_id1", 
                         param = "treatment", 
                         B = 9999, 
                         boot_algo = "WildBootTests.jl", 
                         type = "rademacher")
  res[[x]] <- c(boot_lm1$p_val, boot_lm2$p_val, boot_lm3$p_val, boot_lm4$p_val)
  res
}

cbind("p-values iter 1" = res[[1]], "p-values iter 2" = res[[2]])

```

As can be seen, all p-values are reproducible across languages and random number generators, only by setting a seed via `set.seed()`.

If `boottest()` uses an internal seed, it is exported and can be accessed via 

```{r, message = FALSE, warning = FALSE}
boot_lm1$internal_seed
```


### A Julia Example 

Here is a more concrete example of what happens inside of `boottest()` with 'internal
seeding'. 

In a first step, we define a function `stochastic_julia_fun` that randomly samples an integer in Julia. The function has only one optional function argument, `seed`, and we use the `JuliaConnectoR` package to communicate between R and Julia.

```{r, message = FALSE}
library(JuliaConnectoR)

stochastic_julia_fun <- function(seed = NULL){
  
  if(is.null(seed)){
    seed <- sample.int(.Machine$integer.max, 1)
    JuliaConnectoR::juliaEval('using Random')
    rng_char <- paste0("Random.seed!(", seed, ")")
    JuliaConnectoR::juliaEval(rng_char)
  } else if(!is.null(seed)){
    set.seed(seed)
    seed <- sample.int(.Machine$integer.max, 1)
    JuliaConnectoR::juliaEval('using Random')
    rng_char <- paste0("Random.seed!(", seed, ")")
    JuliaConnectoR::juliaEval(rng_char)
  }
  
  JuliaConnectoR::juliaEval("using StatsBase")
  x <- JuliaConnectoR::juliaEval("sample(1:typemax(Int32))")

  x
  
}

set.seed(1234)
stochastic_julia_fun()
stochastic_julia_fun(seed = 1234)
```

Before creating a random number in Julia for the first time via `stochastic_julia_fun()`, we set a seed in R through the `set.seed()` function. 

```{r, message = FALSE}
set.seed(1234)
stochastic_julia_fun()
```

Within `stochastic_julia_fun()`, the following steps are now executed: 
as no seed has been directly provided, `stochastic_julia_fun()` samples an integer *within* R via the `sample()` function, whose stochastic behavior is determined by the seed set via `set.seed(1234)`. 

```{r}
internal_seed <- sample.int(.Machine$integer.max, 1)
internal_seed
```

In a next step, the drawn integer is passed to Julia and used as the 'global Julia-seed', which then controls the random number generation in Julia.

```{r, message = FALSE}
JuliaConnectoR::juliaEval('using Random')
rng_char <- paste0("Random.seed!(", internal_seed, ")")
JuliaConnectoR::juliaEval(rng_char)
```

In short, the value `r internal_seed` is used as a seed value in Julia - not `1234` - which is the seed value set in R. But the seed used in Julia is a direct derivative of the R seed and thereby controlled via R's `set.seed()` function.


### An Rcpp Example

For Rcpp, all steps work as in Julia. Note that in the example, I am using the `srand()` and `rand()` functions only for illustrative purposes. Both functions are actually [banned for use on CRAN](https://stackoverflow.com/questions/26698164/building-r-package-found-rand-possibly-from-rand-c-note-when-checking) and are not used in `fwildclusterboot`. 

Let's first define a Rcpp based function that randomly samples an integer: 

```{Rcpp}
#include <Rcpp.h>

//[[Rcpp::export]]
int stochastic_cpp(int seed){
  srand(seed);
  int x = rand();
  return x; 
}
```

```{r, message = FALSE}
stochastic_cpp(seed = 123)
stochastic_cpp(seed = 2)
```

We can proceed as with the Julia seed: 

```{r, message = FALSE, warning = FALSE}
stochastic_rcpp_fun <- function(seed = NULL){
  
  if(is.null(seed)){
    seed <- sample.int(.Machine$integer.max, 1)
  } else if(!is.null(seed)){
    set.seed(seed)
    seed <- sample.int(.Machine$integer.max, 1)
  }
  
  x <- stochastic_cpp(seed = seed)

  x
  
}

set.seed(1234)
stochastic_rcpp_fun()
stochastic_rcpp_fun(seed = 1234)
```

Once again, we have managed to set the stochastic behavior in the rcpp function via `set.seed()` from within R & based on R's global seed.

## Alternative: set the global seed 'yourself'

If you don't like the solution presented above, or want to reproduce results from `fwildclusterboot` before version 0.8, you can set the `boottest()` function argument `internal_seed = FALSE`, in which case random number generation in Julia and via the `dqrng` package no longer inherits from R's global seed. 

```{r, message = FALSE, warning = FALSE}
res <- list()
for(x in 1:2){
  set.seed(1234)
  # random number generation via dqrng: 
  boot_lm1 <- boottest(lm_fit, 
                         clustid = "group_id1", 
                         param = "treatment", 
                         B = 9999, 
                         boot_algo = "R", 
                         type = "rademacher", 
                       internal_seed = FALSE)
  # random number generation via base R: 
  boot_lm2 <- boottest(lm_fit, 
                         clustid = "group_id1", 
                         param = "treatment", 
                         B = 9999, 
                         boot_algo = "R", 
                         type = "mammen", 
                       internal_seed = FALSE)
  boot_lm3 <- boottest(lm_fit, 
                         param = "treatment", 
                         clustid = "group_id1", 
                         B = 9999, 
                         boot_algo = "R-lean", 
                         type = "rademacher", 
                       internal_seed = FALSE)
  # random number generation via the StableRNGs Julia package
  boot_lm4 <- boottest(lm_fit, 
                         clustid = "group_id1", 
                         param = "treatment", 
                         B = 9999, 
                         boot_algo = "WildBootTests.jl", 
                         type = "rademacher", 
                       internal_seed = FALSE)
  res[[x]] <- c(boot_lm1$p_val, boot_lm2$p_val, boot_lm3$p_val, boot_lm4$p_val)
  res
}

cbind("p-values iter 1" = res[[1]], "p-values iter 2" = res[[2]])

```

As you can see, setting a random seed via `set.seed()` guarantees reproducibility for Mammen weights and the "R" algorithm and for the Rcpp based algorithm (because Rcpp can interface R's global seed). But the computed p-values for `boot_algo = "R"` for Rademacher weights and `boot_algo = "WildBootTests.jl` differ. 

For reproducible results, you have to set `dqrng` and Julia seeds when appropriate to guarantee reproducible resuls:

```{r, message = FALSE, warning = FALSE}
res <- list()
for(x in 1:2){
  dqrng::dqset.seed(1234)
  
  JuliaConnectoR::juliaEval('using Random')
  JuliaConnectoR::juliaEval("Random.seed!(1234)")
  
  # random number generation via dqrng: 
  boot_lm1 <- boottest(lm_fit, 
                         clustid = "group_id1", 
                         param = "treatment", 
                         B = 9999, 
                         boot_algo = "R", 
                         type = "rademacher", 
                       internal_seed = FALSE)
 
  # random number generation via the StableRNGs Julia package
  boot_lm4 <- boottest(lm_fit, 
                         clustid = "group_id1", 
                         param = "treatment", 
                         B = 9999, 
                         boot_algo = "WildBootTests.jl", 
                         type = "rademacher", 
                       internal_seed = FALSE)
  res[[x]] <- c(boot_lm1$p_val, boot_lm4$p_val)
  res
}

cbind("p-values iter 1" = res[[1]], "p-values iter 2" = res[[2]])

```

