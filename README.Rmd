---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# fwildclusterboot

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![CRAN status](https://www.r-pkg.org/badges/version/fwildclusterboot)](https://CRAN.R-project.org/package=fwildclusterboot)
<!-- badges: end -->

The `fwildclusterboot` package is an R port of Stata's `boottest` package. 

It implements the fast wild cluster bootstrap algorithm developed in Roodman et al (2019) for regression objects in R. It currently works for regression objects of type `lm`, `felm` and `fixest` from base R and the `lfe` and `fixest` packages. 

The package's central function is `boottest()`. It allows the user to test two-sided, univariate hypotheses using a wild cluster bootstrap. Importantly, it uses the "fast" algorithm developed in Roodman et al, which makes it feasible to calculate test statistics based on a large number of bootstrap draws even for large samples--as long as the number of bootstrapping clusters is not too large.

The `fwildclusterboot` package currently only supports one-dimensional clustering and one-dimensional hypotheses, but allows for an arbitrary number of fixed effects. 

The package is highly experimental and currently does not include any unit tests.

The following will be added in the future: 
- support for clustering of higher dimensions
- support for multivariate hypotheses 
- bootstrap distributions other then the rademacher distribution

## Installation

You can install the released version of `fwildclusterboot` from github by running 

```{r}
library(devtools)
#install_github("al_fisc/fwildclusterboot")
```




```{r, echo=FALSE, include=FALSE, results="hide"}

 # setwd("C:/Users/alexa/Dropbox")
 # devtools::install("fwildclusterboot")
 # devtools::document("fwildclusterboot")
# devtools::test("C:/Users/alexa/Dropbox/fwildclusterboot")
# devtools::check("fwildclusterboot")

# 
#  library(usethis)
#  setwd("C:/Users/au563468/Dropbox/fwildclusterboot")
#  use_package("fixest", type = "Imports")
#  use_package("estimatr", type = "Imports")



# execute all functions in fwildclusterboot 
# setwd("C:/Users/alexa/Dropbox/fwildclusterboot/R")
# file.sources = list.files(pattern="*.R")
# sapply(file.sources, source, .GlobalEnv)

# library(data.table)
```

## The `boottest()` function 

In a first step, simulate a data set with 10000 individual observations that are grouped in 50 clusters and with a small intra-cluster correlation of 0.01. The small intra-cluster correlation implies that, in theory, inference based on cluster-robust covariance estimates should lead to results that are very similar to the bootstrap. 

```{r, warning = FALSE, message=FALSE}
library(fwildclusterboot)


B <- 10000
seed <- 424
set.seed(seed)
voters <- create_data_2(N = 10000, N_G1 = 40, icc1 = 0.01, N_G2 = 40, icc2 = 0.01, numb_fe1 = 10, numb_fe2 = 10)
head(voters)

```

The `fwildclusterboot` package supports estimation of linear models based on 
- `lm()` from `base` R
- `felm()` from `lfe`
- `feols()` from `fixest`

```{r, warning = FALSE, message = FALSE}
library(lfe)
library(fixest)

# 1) boottest based on object of class lm
lm_fit <- lm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration , weights = NULL, data = voters)

# 2) boottest based on object of class fixest
feols_fit <- feols(proposition_vote ~ treatment + ideology1 + log_income , fixef = c("Q1_immigration"), weights = NULL, data = voters)
feols_fit1 <- feols(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
feols_fit2 <- feols(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration, weights = NULL, data = voters)

# 3) bootest based on object of class felm
felm_fit <- felm(proposition_vote ~ treatment + ideology1 + log_income | Q1_immigration | 0 |  group_id1, weights = NULL, data = voters)
felm_fit1 <- felm(proposition_vote ~ treatment + ideology1 + log_income + Q1_immigration, weights = NULL, data = voters)
```

The `boottest` function always calculates p-values for a given univariate hypothesis test.
Second and by default, the boottest function calculates confidence intervals by inversion of the p-value. The user can considerably speed up the inference procedure by setting the argument `conf_int = FALSE`, in which case no confidence intervals are computed.

```{r, warning = FALSE, include = FALSE}
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)

# 2) bootest based on object of class feols
 boot_fixest = boottest(feols_fit, clustid = ~group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
 boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)

# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE, beta = 0)

# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = FALSE)

# microbenchmark(boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE),
#                boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE), times = 10)
```

```{r, warning = FALSE, message=FALSE}
# 1) boottest based on object of class lm
boot_lm = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)

# 2) bootest based on object of class feols
boot_fixest = boottest(feols_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)

boot_fixest1 = boottest(feols_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.05)
# boot_fixest2 = boottest(feols_fit2, clustid = voters$group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0)

# 3) boottest based on object of class felm
boot_felm = boottest(felm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
boot_felm1 = boottest(felm_fit1, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE)
```

The function `summarize_boot` collects the results. 
Boottest further comes with a `tidy` method which, in analogy with the `broom` package, returns the estimation results as a data.frame.

```{r, warning = FALSE, message=FALSE}
summarize_boot(boot_lm)

tidy(boot_lm)
tidy(boot_fixest)
tidy(boot_felm)
tidy(boot_fixest1)
tidy(boot_felm1)

```

Change the confidence level: 

```{r}
boot_lm_5 = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.05)

boot_lm_20 = boottest(lm_fit, clustid = ~ group_id1, B = B, seed = seed, param = "treatment", conf_int = TRUE, beta = 0, alpha = 0.20)

summarize_boot(boot_lm_5)
summarize_boot(boot_lm_20)

confint(feols_fit, "treatment", level = 0.95, se = "cluster", cluster = "group_id1")
confint(feols_fit, "treatment", level = 0.80, se = "cluster", cluster = "group_id1")

```

Plot the confidence sets: 

```{r, out.width="50%"}
plot_boot(boot_lm)
```


## Comparison to `cluster.boot()` from `multiwayvcov`

The `multiwayvcov` package offers an alternative implementation of the wild bootstrap. 
As can be seen, `multiwayvcov::cluster.boot()`, `boottest()` and sandwich standard errors produce similar results: 

```{r, warning = FALSE, message=FALSE}
library(multiwayvcov)
library(lmtest)
options(boot.ncpus = 4)

res <- cluster.boot(lm_fit, cluster = ~ group_id1, parallel = FALSE, R = 1000, wild_type = "rademacher")

# 1) results from multiwayvcov
coeftest(lm_fit, res)

# 2) results from fwildclusterboot
summarize_boot(boot_lm)
summarize_boot(boot_fixest)


# 3) sandwich standard errors 
vocv <- vcovCL(lm_fit, ~ group_id1)
coeftest(lm_fit, vcov)

```


## Some Tests with 2-way clustering 

```{r}
library(sandwich)
library(lmtest)
library(multiwayvcov)
options(boot.ncpus = 4)
rm(boot_lm); rm(boot_fixest); rm(boot_felm); rm(res)

boot_lm <-  boottest(lm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
boot_fixest <-  boottest(feols_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
# boot_felm <-  boottest(felm_fit, clustid = ~group_id1 + group_id2, B = 1000, seed = seed, param = "treatment", conf_int = FALSE)
summarize_boot(boot_lm)
summarize_boot(boot_fixest)
summarize_boot(boot_felm)


vocv <- vcovCL(lm_fit, ~ group_id1 + group_id2)
coeftest(lm_fit, vcov)

res <- cluster.boot(lm_fit, cluster = ~group_id1 + group_id2, R = 1000, wild_type = "rademacher", parallel = TRUE)
# # 1) results from multiwayvcov

coeftest(lm_fit, res)

#confint(feols_fit, "treatment", level = 0.95, se = "twoway", cluster = c("group_id1", "group_id2"))
```



## Benchmark 

Results of timing benchmarks of `fwildclusterboot` with `multiwayvcov` (on 4 cores) with
- N = 10000 observations
- b = 10000 bootstrap iterations
- n_g = 50 clusters


```{r, warnings = FALSE, echo = FALSE,  out.width="50%"}
#knitr::include_graphics("C:/Users/alexa/Dropbox/fwildclusterboot/benchmar#ks/bench_boottest.png")
#bench <- readRDS("C:/Users/alexa/Dropbox/fwildclusterboot/benchmarks/benc#h_boottest.rds")
#print(bench)
# library(microbenchmark)
# options(boot.ncpus = 4)
# 
# 
# bench <- 
#     microbenchmark(
#       # multiway = cluster.boot(lm_fit, cluster = voters$group_id1, parallel = FALSE, R = B, wild_type = "rademacher"),
#       multiway_parallel = cluster.boot(lm_fit, cluster = voters$group_id1, parallel = TRUE, R = B, wild_type = "rademacher"),
#       boottest_lm = boottest(lm_fit, clustid = voters$group_id1, B = B, param = "treatment"), 
#       boottest_feols = boottest(feols_fit, clustid = voters$group_id1, B = B, param = "treatment"),
#       #boottest_lm_p_val = boottest(lm_fit, clustid = voters$group_id1, B = b, param = "treatment", conf_int = FALSE), 
#       #boottest_feols_p_val = boottest(feols_fit, clustid = voters$group_id1, B = b, param = "treatment", conf_int = FALSE),
#       times = 3
# )
# 
# bench
```


