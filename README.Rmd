---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# fwildclusterboot

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![CRAN status](https://www.r-pkg.org/badges/version/fwildclusterboot)](https://CRAN.R-project.org/package=fwildclusterboot)
<!-- badges: end -->

The goal of fwildclusterboot is to estimate a fast wild cluster bootstrap for linear regression models of classes "lm", "lm_robust" and "felm" (from packages base, estimatr and lfe).

## Installation

You can install the released version of fwildclusterboot from github...

``` r
install.packages("fwildclusterboot")
```

## Example

This is a basic example which shows you how to solve a common problem:

```{r, echo=FALSE, include=FALSE, results="hide"}
#' Fast Wild Cluster Bootstrap
#' 
#' This function conducts a fast wild cluster bootstrap as in Cameron et al... 
#' 


# boottest <- function(object, 
#                      clustid, 
#                      param, 
#                      B,
#                      debug = FALSE, 
#                      seed = NULL, 
#                      object_type = class(object), 
#                      data = NULL){
#   
#   
#   
#   
#   if(!(object_type %in% c("lm", "felm"))){
#     break("Model is not of class lm.")
#   }
#   if(object_type == "felm" & is.null(data)){
#     break("Objects of class felm require you to pass in the input data set, which means you need to pass in the same data set that you pass into felm().")
#   }
#   
#   
#   if(!is.null(seed)){
#     set.seed(seed)
#   } else if(is.null(seed)){
#     set.seed(2)
#   }
#   
#   # retrieve clusters / multiple clusters
#   if(inherits(clustid, "formula")) {
#     clustid_tmp <- expand.model.frame(object, clustid, na.expand = FALSE)
#     clustid <- model.frame(clustid, clustid_tmp, na.action = na.pass)
#   } else {
#     clustid <- as.data.frame(clustid, stringsAsFactors = FALSE)
#   }
#   
#   if(!(param %in% c(names(object$coefficients)))){
#     warning("Parameter to test not in model or all. Please specify appropriate parameters to test.")
#   }
#   
#   # how many clustids? uniway/multiway?
#   clustid_dims <- ncol(clustid)
#   
#   
#   # Handle omitted or excluded observations
#   if(!is.null(object$na.action)) {
#     if(class(object$na.action) == "exclude") {
#       clustid <- clustid[-object$na.action,]
#     } else if(class(object$na.action) == "omit") {
#       clustid <- clustid[-object$na.action,]
#     }
#     clustid <- as.data.frame(clustid)  # silly error somewhere
#   }
#   #if(debug) print(class(clustid))
#   
#   # Factors in our clustiding variables can potentially cause problems
#   # Blunt fix is to force conversion to characters
#   i <- !sapply(clustid, is.numeric)
#   clustid[i] <- lapply(clustid[i], as.character)
#   
#   # Make all combinations of clustid dimensions
#   # if(clustid_dims > 1) {
#   #   for(i in acc) {
#   #     clustid <- cbind(clustid, Reduce(paste0, clustid[,i]))
#   #   }
#   # }
# 
#   
#   # start estimation here: 
#   
#   R0 <- as.numeric(param == names(object$coefficients))
#   groupvars <- names(coef(object))
#   
#   if(object_type == "felm"){
#     
#     depvar <- names(object$response)
#     Y <- object$response
#     X <- lfe:::model.matrix.felm(felm_fit) 
#   }
#   
#   if(object_type == "lm"){
#     
#     depvar <- all.vars(as.formula(object$call))[1]
#     #measurevar <- "y"
#     #formula <- as.formula(paste(measurevar, paste(groupvars, collapse=" + "), sep=" ~ "))
#     
#     X <- model.matrix(as.formula(object$call), data = object$model)
#     Y <- as.matrix(model.frame(object)[, depvar])  
#   }
#   
#   N <- length(Y)
#   k <- ncol(X)
#   
#   Xr <- X[, -which(R0 == 1)] # delete rows that will be tested
# 
# 
#   
#   #clustid <- as.vector(clustid)
#   #clustid <- rep(1:20, 100)
#   N_G <- nrow(unique(clustid)) #number of clusters
#   if(N_G > 2000){
#     warning(paste("You are estimating a model with more than 200 clusters. Are you sure you want to proceed with bootstrap standard errors instead of asymptotic sandwich standard errors? The more clusters in the data, the longer the estimation process."))
#   }
#   
#   # error under the null hypothesis
#   u_hat <- Y - Xr %*% solve(t(Xr) %*% Xr) %*% t(Xr) %*% Y # N x 1 matrix
#   
#   invXX <- solve(t(X) %*% X) # k x k matrix
#   
#   v <- matrix(sample(c(1, -1), N_G * (B + 1), replace = TRUE), N_G, B + 1) # rademacher weights for all replications
#   v[,1] <- 1
#   
#   XinvXXr <- X %*% (invXX %*% R0) # N x 1
#   SXinvXXRu_prep <- data.table(prod = XinvXXr * matrix(rep(u_hat, 1), N, 1) , clustid = clustid) 
#   SXinvXXRu <- as.matrix(SXinvXXRu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
#   
#   if(ncol(SXinvXXRu) == 1){
#     SXinvXXRu <- as.vector(SXinvXXRu)
#   }
#   
#   SXinvXXRX_prep <- data.table(prod = matrix(rep(XinvXXr, k), N, k) * X, clustid = clustid)
#   SXinvXXRX <- as.matrix(SXinvXXRX_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
#   
#   SXu_prep <- data.table::data.table(prod = X * matrix(rep(u_hat, k), N, k), clustid = clustid) 
#   SXu <- as.matrix(SXu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
#   
#   numer <- SXinvXXRu %*% v
#   J <- (diag(SXinvXXRu) - SXinvXXRX  %*% invXX %*% t(SXu)) %*% v  
#   
#   t <- abs(numer)  / sqrt(colSums(J * J))       
#   
#   p_val <- mean(t[1] < t[2:(B + 1)])
#   
#   paste("The wild cluster bootstrap p-value for the parameter", param, "is", p_val, ",", "with B", B,  "bootstrap iterations.")
#   
#   
# } 




# Rewrite for OOP


boottest <- function(x, ...){UseMethod("boottest")}

#' method for object of class "lm"
#'@export
boottest.lm <- function(object, 
                        clustid, 
                        param, 
                        B,
                        debug = FALSE, 
                        seed = NULL){
  
  

  
  
  if(!is.null(seed)){
    set.seed(seed)
  } else if(is.null(seed)){
    set.seed(2)
  }
  
  # retrieve clusters / multiple clusters
  if(inherits(clustid, "formula")) {
    clustid_tmp <- expand.model.frame(object, clustid, na.expand = FALSE)
    clustid <- model.frame(clustid, clustid_tmp, na.action = na.pass)
  } else {
    clustid <- as.data.frame(clustid, stringsAsFactors = FALSE)
  }
  
  if(!(param %in% c(names(object$coefficients)))){
    warning("Parameter to test not in model or all. Please specify appropriate parameters to test.")
  }
  
  # how many clustids? uniway/multiway?
  clustid_dims <- ncol(clustid)
  
  
  # Handle omitted or excluded observations
  if(!is.null(object$na.action)) {
    if(class(object$na.action) == "exclude") {
      clustid <- clustid[-object$na.action,]
    } else if(class(object$na.action) == "omit") {
      clustid <- clustid[-object$na.action,]
    }
    clustid <- as.data.frame(clustid)  # silly error somewhere
  }
  #if(debug) print(class(clustid))
  
  # Factors in our clustiding variables can potentially cause problems
  # Blunt fix is to force conversion to characters
  i <- !sapply(clustid, is.numeric)
  clustid[i] <- lapply(clustid[i], as.character)
  
  # Make all combinations of clustid dimensions
  # if(clustid_dims > 1) {
  #   for(i in acc) {
  #     clustid <- cbind(clustid, Reduce(paste0, clustid[,i]))
  #   }
  # }
  
  
  # start estimation here: 
  
  R0 <- as.numeric(param == names(object$coefficients))
  groupvars <- names(coef(object))
  
  # if(object_type == "felm"){
  #   
  #   depvar <- names(object$response)
  #   Y <- object$response
  #   X <- lfe:::model.matrix.felm(felm_fit) 
  # }
  

    depvar <- all.vars(as.formula(object$call))[1]
    #measurevar <- "y"
    #formula <- as.formula(paste(measurevar, paste(groupvars, collapse=" + "), sep=" ~ "))
    
    X <- model.matrix(as.formula(object$call), object$model)
    Y <- as.matrix(model.frame(object)[, depvar])  

  
  N <- length(Y)
  k <- ncol(X)
  
  Xr <- X[, -which(R0 == 1)] # delete rows that will be tested
  
  
  
  #clustid <- as.vector(clustid)
  #clustid <- rep(1:20, 100)
  N_G <- nrow(unique(clustid)) #number of clusters
  if(N_G > 2000){
    warning(paste("You are estimating a model with more than 200 clusters. Are you sure you want to proceed with bootstrap standard errors instead of asymptotic sandwich standard errors? The more clusters in the data, the longer the estimation process."))
  }
  
  # error under the null hypothesis
  u_hat <- Y - Xr %*% solve(t(Xr) %*% Xr) %*% t(Xr) %*% Y # N x 1 matrix
  
  invXX <- solve(t(X) %*% X) # k x k matrix
  
  v <- matrix(sample(c(1, -1), N_G * (B + 1), replace = TRUE), N_G, B + 1) # rademacher weights for all replications
  v[,1] <- 1
  
  XinvXXr <- X %*% (invXX %*% R0) # N x 1
  SXinvXXRu_prep <- data.table::data.table(prod = XinvXXr * matrix(rep(u_hat, 1), N, 1) , clustid = clustid) 
  SXinvXXRu <- as.matrix(SXinvXXRu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
  
  if(ncol(SXinvXXRu) == 1){
    SXinvXXRu <- as.vector(SXinvXXRu)
  }
  
  SXinvXXRX_prep <- data.table::data.table(prod = matrix(rep(XinvXXr, k), N, k) * X, clustid = clustid)
  SXinvXXRX <- as.matrix(SXinvXXRX_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
  
  SXu_prep <- data.table::data.table(prod = X * matrix(rep(u_hat, k), N, k), clustid = clustid) 
  SXu <- as.matrix(SXu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
  
  numer <- SXinvXXRu %*% v
  J <- (diag(SXinvXXRu) - SXinvXXRX  %*% invXX %*% t(SXu)) %*% v  
  
  t <- abs(numer)  / sqrt(colSums(J * J))       
  
  p_val <- mean(t[1] < t[2:(B + 1)])
  
  paste("The wild cluster bootstrap p-value for the parameter", param, "is", p_val, ",", "with B", B,  "bootstrap iterations.")
  
  
} 






#' method for object of class "lm_robust"
#'@export
boottest.lm_robust <- boottest <- function(object, 
                                           clustid, 
                                           param, 
                                           B,
                                           data,
                                           debug = FALSE, 
                                           seed = NULL){
  
  
  
  
  
  if(!is.null(seed)){
    set.seed(seed)
  } else if(is.null(seed)){
    set.seed(2)
  }
  
  # retrieve clusters / multiple clusters
  if(inherits(clustid, "formula")) {
    clustid_tmp <- expand.model.frame(object, clustid, na.expand = FALSE)
    clustid <- model.frame(clustid, clustid_tmp, na.action = na.pass)
  } else {
    clustid <- as.data.frame(clustid, stringsAsFactors = FALSE)
  }
  
  if(!(param %in% c(names(object$coefficients)))){
    warning("Parameter to test not in model or all. Please specify appropriate parameters to test.")
  }
  
  # how many clustids? uniway/multiway?
  clustid_dims <- ncol(clustid)
  
  
  # Handle omitted or excluded observations
  if(!is.null(object$na.action)) {
    if(class(object$na.action) == "exclude") {
      clustid <- clustid[-object$na.action,]
    } else if(class(object$na.action) == "omit") {
      clustid <- clustid[-object$na.action,]
    }
    clustid <- as.data.frame(clustid)  # silly error somewhere
  }
  #if(debug) print(class(clustid))
  
  # Factors in our clustiding variables can potentially cause problems
  # Blunt fix is to force conversion to characters
  i <- !sapply(clustid, is.numeric)
  clustid[i] <- lapply(clustid[i], as.character)
  
  # Make all combinations of clustid dimensions
  # if(clustid_dims > 1) {
  #   for(i in acc) {
  #     clustid <- cbind(clustid, Reduce(paste0, clustid[,i]))
  #   }
  # }
  
  
  # start estimation here: 
  
  # names(object$coefficients) == NULL for class == lm_robust
  R0 <- as.numeric(param == names(coef(object))) 
  
  groupvars <- names(coef(object))
  
  #if(object_type == "felm"){
    
    depvar <- names(object$response)
    model_frame <- model.frame(as.formula(object$call), data = data)
    Y <- model.response(model_frame)
    X <- model.matrix(as.formula(object$call), data = data)
  #}
  
  #if(object_type == "lm"){
    
  #  depvar <- all.vars(as.formula(object$call))[1]
    #measurevar <- "y"
    #formula <- as.formula(paste(measurevar, paste(groupvars, collapse=" + "), sep=" ~ "))
    
  #  X <- model.matrix(as.formula(object$call), data = object$model)
  #  Y <- as.matrix(model.frame(object)[, depvar])  
  #}
  
  N <- length(Y)
  k <- ncol(X)
  
  Xr <- X[, -which(R0 == 1)] # delete rows that will be tested
  
  
  
  #clustid <- as.vector(clustid)
  #clustid <- rep(1:20, 100)
  N_G <- nrow(unique(clustid)) #number of clusters
  if(N_G > 2000){
    warning(paste("You are estimating a model with more than 200 clusters. Are you sure you want to proceed with bootstrap standard errors instead of asymptotic sandwich standard errors? The more clusters in the data, the longer the estimation process."))
  }
  
  # error under the null hypothesis
  u_hat <- Y - Xr %*% solve(t(Xr) %*% Xr) %*% t(Xr) %*% Y # N x 1 matrix
  
  invXX <- solve(t(X) %*% X) # k x k matrix
  
  v <- matrix(sample(c(1, -1), N_G * (B + 1), replace = TRUE), N_G, B + 1) # rademacher weights for all replications
  v[,1] <- 1
  
  XinvXXr <- X %*% (invXX %*% R0) # N x 1
  SXinvXXRu_prep <- data.table(prod = XinvXXr * matrix(rep(u_hat, 1), N, 1) , clustid = clustid) 
  SXinvXXRu <- as.matrix(SXinvXXRu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
  
  if(ncol(SXinvXXRu) == 1){
    SXinvXXRu <- as.vector(SXinvXXRu)
  }
  
  SXinvXXRX_prep <- data.table(prod = matrix(rep(XinvXXr, k), N, k) * X, clustid = clustid)
  SXinvXXRX <- as.matrix(SXinvXXRX_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
  
  SXu_prep <- data.table::data.table(prod = X * matrix(rep(u_hat, k), N, k), clustid = clustid) 
  SXu <- as.matrix(SXu_prep[, lapply(.SD, sum), by = "clustid.clustid"][, clustid.clustid := NULL])
  
  numer <- SXinvXXRu %*% v
  J <- (diag(SXinvXXRu) - SXinvXXRX  %*% invXX %*% t(SXu)) %*% v  
  
  t <- abs(numer)  / sqrt(colSums(J * J))       
  
  p_val <- mean(t[1] < t[2:(B + 1)])
  
  paste("The wild cluster bootstrap p-value for the parameter", param, "is", p_val, ",", "with B", B,  "bootstrap iterations.")
  
  
} 


```


```{r, echo=FALSE, include=FALSE, results="hide"}
#bothPaths <- .libPaths()   # extract both paths
#bothPaths <- c(bothPaths [2], bothPaths [1])  # change order
#.libPaths(bothPaths )  # modify the order
#setwd("C:/Users/au563468/Dropbox")
#devtools::install("fwildclusterboot")
#devtools::document("fwildclusterboot")

library(data.table)
library(estimatr)
library(magrittr)
library(mvtnorm)
library(multiwayvcov)
library(lmtest)
library(lfe)
```


```{r example}

library(fwildclusterboot)

## basic example code

seed <- sample(1:1000, 1)
seed
 
gen_cluster <- function(param = c(1, 0), n = 20000, n_cluster = 50, rho = .8) {
 # source: https://yukiyanai.github.io/teaching/rm1/contents/R/clustered-data-analysis.html
 # Function to generate clustered data
 # Required package: mvtnorm
 
 # individual level
 Sigma_i <- matrix(c(1, 0, 0, 1 - rho), ncol = 2)
 values_i <- rmvnorm(n = n, sigma = Sigma_i)
 
 # cluster level
 cluster_name <- rep(1:n_cluster, each = n / n_cluster)
 Sigma_cl <- matrix(c(1, 0, 0, rho), ncol = 2)
 values_cl <- rmvnorm(n = n_cluster, sigma = Sigma_cl)
 
 # predictor var consists of individual- and cluster-level components
 x <- values_i[ , 1] + rep(values_cl[ , 1], each = n / n_cluster)
 
 # error consists of individual- and cluster-level components
 error <- values_i[ , 2] + rep(values_cl[ , 2], each = n / n_cluster)
 
 # data generating process
 y <- param[1] + param[2]*x + error
 
 df <- data.frame(x, y, cluster = cluster_name)
 data.table::setDT(df)
 return(df)
}
# 
data <- gen_cluster()
#head(data)
#data[, mean(y)]

 
lm_fit <- lm(y ~ x, data = data)

 
# standard bootstrap
B <- 10000
 
```

As can be seen, the fast bootstrap is much faster. 

```{r}
# basic bootstrap, not parallel
system.time(boot_fit <- multiwayvcov::cluster.boot(lm_fit, 
                           as.factor(data$cluster), 
                           R = B, 
                           boot_type = "residual", 
                           wild_type = "rademacher", 
                           parallel = TRUE))
 
 
system.time(
  boottest.lm(lm_fit, clustid = data$cluster, B = B, seed = seed, param = "x")
)
```

And let's have a look at the output: 

```{r}
lmtest::coeftest(lm_fit, boot_fit)

boottest.lm(lm_fit, clustid = data$cluster, B = B, seed = seed, param = "(Intercept)")
boottest.lm(lm_fit, clustid = data$cluster, B = B, seed = seed, param = "x")

lm_robust_fit <- lm_robust(y ~ x, data = data, clusters = cluster)
lm_robust_fit %>% 
summary()
# does the method work with object lm_robust?
#boottest.lm_robust(lm_robust_fit, clustid = data$cluster, B = B, seed = seed, param = "(Intercept)") # ror: need to feed in data
boottest.lm_robust(lm_robust_fit, data = data, clustid = data$cluster, B = B, seed = seed, param = "x") 
```

